{"comment":"Sstan","footnote":"","findings":[{"severity":"Low","title":"Unsafe ERC20 Operation","description":"\"\"\n        ERC20 operations can be unsafe due to different implementations and vulnerabilities in the standard. To account for this, either use OpenZeppelin's SafeERC20 library or wrap each operation in a require statement. \\n\n        > Additionally, ERC20's approve functions have a known race-condition vulnerability. To account for this, use OpenZeppelin's SafeERC20 library's `safeIncrease` or `safeDecrease` Allowance functions.\n        <details>\n        <summary>Expand Example</summary>\n\n        #### Unsafe Transfer\n\n        ```js\n        IERC20(token).transfer(msg.sender, amount);\n        ```\n\n        #### OpenZeppelin SafeTransfer\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransfer(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe Transfer with require statement.\n\n        ```js\n        bool success = IERC20(token).transfer(msg.sender, amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n                \n        #### Unsafe TransferFrom\n\n        ```js\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n        ```\n\n        #### OpenZeppelin SafeTransferFrom\n\n        ```js\n        import {SafeERC20} from \\\"openzeppelin/token/utils/SafeERC20.sol\\\";\n        //--snip--\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        ```\n                \n        #### Safe TransferFrom with require statement.\n\n        ```js\n        bool success = IERC20(token).transferFrom(msg.sender, address(this), amount);\n        require(success, \\\"ERC20 transfer failed\\\");\n        ```\n\n        </details>\n        \"\"","gasSavings":null,"category":null,"instances":[{"content":["41:        IERC721(_nft).transferFrom(msg.sender, address(this), _tokenId);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["66:            participant.transfer(raffle.ticketPrice);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["98:        payable(owner()).transfer(address(this).balance);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["220:        require(rewardToken.transferFrom(msg.sender, address(this), _amount), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["315:        require(rewardToken.transfer(msg.sender, rewards), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["342:            require(IERC20(_tokenAddress).transfer(owner(), amountToSend), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["351:            require(IERC20(_tokenAddress).transfer(owner(), _amount), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["84:        payable(owner()).transfer(amount);\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]}]},{"severity":"NonCritical","title":"Private variables should contain a leading underscore","description":"Consider adding an underscore to the beginning of the variable name","gasSavings":null,"category":null,"instances":[{"content":["42:    uint256 private rewardTokenBalance;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["48:    uint8 internal isStaking = 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["39:    uint64 private nextConditionId;\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"NonCritical","title":"Constructor should check that all parameters are not 0","description":"Consider adding a require statement to check that all parameters are not 0 in the constructor","gasSavings":null,"category":null,"instances":[{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["99:    constructor(\n100:        string memory _collectionName,\n101:        string memory _description,\n102:        address _collectionAddress,\n103:        address _rewardTokenAddress,\n104:        uint256 _stakingFee,\n105:        address initialOwner,\n106:        uint256 _timeUnit,\n107:        uint256 _rewardsPerUnitTime,\n108:        uint256 _endDate\n109:    )\n110:        Ownable(initialOwner)\n111:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["27:    constructor(uint256 _fee) Ownable(msg.sender) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]}]},{"severity":"NonCritical","title":"This error has no parameters, the state of the contract when the revert occured will not be available","description":"Consider adding parameters to the error to provide more context when a transaction fails","gasSavings":null,"category":null,"instances":[{"content":["25:    error Gaia_NotNFTOwner();\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["26:    error Gaia_RaffleNotActive();\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["27:    error Gaia_MaxTicketExceeded();\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["28:    error Gaia_NotEnoughFund();\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["21:    error Gaia_NotEnoughEtherToCoverFee();\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["87:    error GaiaStake_EmptyCollectionName();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["88:    error GaiaStake_EmptyDescription();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["89:    error GaiaStake_AddressCantBeZero();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["90:    error GaiaStake_InvalidStakingFee();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["91:    error GaiaStake_StakingEnded();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["92:    error GaiaStake_UnstakeAmountTooHigh();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["93:    error GaiaStake_NoNFTToUnStake();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["94:    error Gaiane_HasNoEndTime();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["95:    error Gaia_NotStaker();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["96:    error Gaia_NoStakingCondition();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["97:    error Gaia_InvalidTimeUnit();\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"NonCritical","title":"Function names should be in camelCase","description":"Ensure that function definitions are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]}]},{"severity":"NonCritical","title":"Consider marking public function External","description":"If a public function is never called internally, it is best practice to mark it as external.","gasSavings":null,"category":null,"instances":[{"content":["336:    function recoverERC20(address _tokenAddress, uint256 _amount) public onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["80:    function withdrawEther() public onlyOwner returns (uint256 amount) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]}]},{"severity":"NonCritical","title":"Function parameters should be in camelCase","description":"Ensure that function parameters are declared using camelCase","gasSavings":null,"category":null,"instances":[{"content":["37:    function createRaffle(IERC721 _nft, uint256 _tokenId, uint256 _ticketPrice, uint256 _maxTickets) external {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["78:    function purchaseTickets(uint256 raffleId, uint256 tickets) external payable {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["27:    constructor(uint256 _fee) Ownable(msg.sender) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["49:        string memory _description,\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["80:    function withdrawEther() public onlyOwner returns (uint256 amount) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["101:        string memory _description,\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["216:    function depositRewardTokens(uint256 _amount) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["229:    function _updateUnclaimedRewardsForStaker(address _staker) internal virtual {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["236:    function _calculateRewards(address _staker) internal view returns (uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["236:    function _calculateRewards(address _staker) internal view returns (uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["274:    function getStakeInfo(address _staker) external view returns (uint256[] memory _tokensStaked, uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["274:    function getStakeInfo(address _staker) external view returns (uint256[] memory _tokensStaked, uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["298:    function _availableRewards(address _user) internal view virtual returns (uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["298:    function _availableRewards(address _user) internal view virtual returns (uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["321:        address operator,\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["322:        address from,\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["324:        bytes calldata data\n325:    )\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["336:    function recoverERC20(address _tokenAddress, uint256 _amount) public onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]}]},{"severity":"NonCritical","title":"Consider explicitly naming mapping parameters","description":"Consider explicitly naming mapping parameters for readability","gasSavings":null,"category":null,"instances":[{"content":["18:    mapping(uint256 raffleId => Raffle) public raffles;\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["51:    mapping(uint256 _tokenIds => bool) public isIndexed;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["54:    mapping(address staker => Staker) public stakers;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["57:    mapping(uint256 _tokenIds => StakingCondition) private stakingConditions;\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Tightly pack storage variables","description":"\n When defining storage variables, make sure to declare them in ascending order, according to size. When multiple variables are able to fit into one 256 bit slot, this will save storage size and gas during runtime. For example, if you have a `bool`, `uint256` and a `bool`, instead of defining the variables in the previously mentioned order, defining the two boolean variables first will pack them both into one storage slot since they only take up one byte of storage. - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["24:    string public collectionName;\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Avoid Reading From Storage in a for loop","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["95:        for (uint256 i = 0; i < count; i++) {\n96:            contracts[i] = deployedContracts.at(i);\n97:        }\n98:\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n143:            isStaking = 2;\n144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n145:            isStaking = 1;\n146:\n147:            stakerAddress[_tokenIds[i]] = msg.sender;\n148:\n149:            if (!isIndexed[_tokenIds[i]]) {\n150:                isIndexed[_tokenIds[i]] = true;\n151:                indexedTokens.push(_tokenIds[i]);\n152:            }\n153:        }\n154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["179:        for (uint256 i = 0; i < len; ++i) {\n180:            if (stakerAddress[_tokenIds[i]] != msg.sender) revert Gaia_NotStaker();\n181:            stakerAddress[_tokenIds[i]] = address(0);\n182:            collectionAddress.safeTransferFrom(address(this), msg.sender, _tokenIds[i]);\n183:        }\n184:\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Mark storage variables as `immutable` if they never change after contract initialization.","description":"\n State variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time. \n The compiler does not reserve a storage slot for these variables, and every occurrence is inlined by the respective value. \n Compared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values. \n - Savings: ~2103 \n","gasSavings":null,"category":null,"instances":[{"content":["25:    string public description;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["24:    string public collectionName;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["26:    IERC721 public collectionAddress;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["27:    address public rewardTokenAddress;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["28:    uint256 public stakingFee;\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"`unchecked{++i}` instead of `i++` (or use assembly when applicable)","description":"\n Use `++i` instead of `i++`. This is especially useful in for loops but this optimization can be used anywhere in your code. You can also use `unchecked{++i;}` for even more gas savings but this will not check to see if `i` overflows. For extra safety if you are worried about this, you can add a require statement after the loop checking if `i` is equal to the final incremented value. For best gas savings, use inline assembly, however this limits the functionality you can achieve. For example you cant use Solidity syntax to internally call your own contract within an assembly block and external calls must be done with the `call()` or `delegatecall()` instruction. However when applicable, inline assembly will save much more gas. - Savings: ~342 \n","gasSavings":null,"category":null,"instances":[{"content":["95:        for (uint256 i = 0; i < count; i++) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["287:        for (uint256 i = 0; i < indexedTokenCount; i++) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["364:        for (uint256 i = 0; i < stakersArray.length; i++) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["179:        for (uint256 i = 0; i < len; ++i) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["142:        for (uint256 i = 0; i < len; ++i) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["280:        for (uint256 i = 0; i < indexedTokenCount; i++) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["169:            for (uint256 i = 0; i < _stakersArray.length; ++i) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["86:        for (uint256 i = 0; i < tickets; i++) {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["64:        for (uint256 i = 0; i < raffle.participants.length; i++) {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["55:        nextRaffleId++;\n"],"loc":["./src/Raffle/Raffle.sol"]}]},{"severity":"Gas","title":"Cache Storage Variables in Memory","description":"\n  - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["96:            contracts[i] = deployedContracts.at(i);\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["53:        emit RaffleCreated(nextRaffleId, msg.sender, _nft, _tokenId);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["55:        nextRaffleId++;\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["138:            stakers[msg.sender].timeOfLastUpdate = uint128(block.timestamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["139:            stakers[msg.sender].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["145:            isStaking = 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["150:                isIndexed[_tokenIds[i]] = true;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["138:            stakers[msg.sender].timeOfLastUpdate = uint128(block.timestamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["139:            stakers[msg.sender].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["144:            collectionAddress.safeTransferFrom(msg.sender, address(this), _tokenIds[i]);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["145:            isStaking = 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["150:                isIndexed[_tokenIds[i]] = true;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["154:        stakers[msg.sender].amountStaked += len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["171:                    stakersArray[i] = _stakersArray[_stakersArray.length - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["172:                    stakersArray.pop();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["177:        stakers[msg.sender].amountStaked -= len;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["181:            stakerAddress[_tokenIds[i]] = address(0);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["232:        stakers[_staker].timeOfLastUpdate = uint128(block.timestamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["233:        stakers[_staker].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["232:        stakers[_staker].timeOfLastUpdate = uint128(block.timestamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["233:        stakers[_staker].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["260:        nextConditionId += 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["270:            stakingConditions[conditionId - 1].endTimestamp = block.timestamp;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["300:            _rewards = stakers[_user].unclaimedRewards;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["302:            _rewards = stakers[_user].unclaimedRewards + _calculateRewards(_user);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["300:            _rewards = stakers[_user].unclaimedRewards;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["302:            _rewards = stakers[_user].unclaimedRewards + _calculateRewards(_user);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["311:        stakers[msg.sender].timeOfLastUpdate = uint128(block.timestamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["312:        stakers[msg.sender].unclaimedRewards = 0;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["313:        stakers[msg.sender].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["340:            uint256 amountToSend = rewardToken.balanceOf(address(this)) - rewardTokenBalance;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["340:            uint256 amountToSend = rewardToken.balanceOf(address(this)) - rewardTokenBalance;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["365:            totalStakedAmount += stakers[stakersArray[i]].amountStaked;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["379:        StakingCondition memory latestCondition = stakingConditions[nextConditionId - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Use assembly to check for address(0)","description":"\n  - Savings: ~6 \n","gasSavings":null,"category":null,"instances":[{"content":["115:        if (_collectionAddress == address(0)) revert GaiaStake_AddressCantBeZero();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["116:        if (_rewardTokenAddress == address(0)) revert GaiaStake_AddressCantBeZero();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["337:        if (_tokenAddress == address(0)) revert GaiaStake_AddressCantBeZero();\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Optimal Comparison","description":"\n When comparing integers, it is cheaper to use strict `>` & `<` operators over `>=` & `<=` operators, even if you must increment or decrement one of the operands. \n Note: before using this technique, it's important to consider whether incrementing/decrementing one of the operators could result in an over/underflow. This optimization is applicable when the optimizer is turned off. - Savings: ~3 \n","gasSavings":null,"category":null,"instances":[{"content":["132:        if (collectionAddress.balanceOf(msg.sender) >= len) revert Gaiane_BalanceTooLow(len);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["348:            require(_amount <= tokenBalance, \"Amount exceeds token balance\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["382:        if (latestCondition.timeUnit <= 0) revert Gaia_InvalidTimeUnit();\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["405:        if (remainingDuration <= 0) revert GaiaStake_StakingEnded();\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Use `calldata` instead of `memory` for function arguments that do not get mutated.","description":"\n Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage. - Savings: ~1716 \n","gasSavings":null,"category":null,"instances":[{"content":["48:        string memory _collectionName,\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["49:        string memory _description,\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]}]},{"severity":"Gas","title":"Use custom errors instead of string error messages","description":"\n Using custom errors will save you gas, and can be used to provide more information about the error. - Savings: ~57 \n","gasSavings":null,"category":null,"instances":[{"content":["190:        require(_rewardsPerUnitTime != condition.rewardsPerUnitTime, \"Reward unchanged.\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["199:        require(_timeUnit != condition.timeUnit, \"Time-unit unchanged.\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["209:        require(_endTimestamp != condition.endTimestamp, \"Time-unit unchanged.\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["217:        require(_amount > 0, \"Amount must be greater than 0\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["220:        require(rewardToken.transferFrom(msg.sender, address(this), _amount), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["258:        require(_timeUnit != 0, \"time-unit can't be 0\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["309:        require(rewards != 0, \"No rewards\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["315:        require(rewardToken.transfer(msg.sender, rewards), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["331:        require(isStaking == 2, \"Direct transfer\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["342:            require(IERC20(_tokenAddress).transfer(owner(), amountToSend), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["348:            require(_amount <= tokenBalance, \"Amount exceeds token balance\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["351:            require(IERC20(_tokenAddress).transfer(owner(), _amount), \"Token transfer failed\");\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Use assembly for math (add, sub, mul, div)","description":"\n Use assembly for math instead of Solidity. You can check for overflow/underflow in assembly to ensure safety. If using Solidity versions < 0.8.0 and you are using Safemath, you can gain significant gas savings by using assembly to calculate values and checking for overflow/underflow. - Savings: ~60 \n","gasSavings":null,"category":null,"instances":[{"content":["139:            stakers[msg.sender].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["171:                    stakersArray[i] = _stakersArray[_stakersArray.length - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["189:        StakingCondition memory condition = stakingConditions[nextConditionId - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["198:        StakingCondition memory condition = stakingConditions[nextConditionId - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["207:        StakingCondition memory condition = stakingConditions[nextConditionId - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["208:        _endTimestamp = block.timestamp + _endTimestamp;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["233:        stakers[_staker].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["248:            uint256 rewardsProduct = (endTime - startTime) * staker.amountStaked * condition.rewardsPerUnitTime;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["248:            uint256 rewardsProduct = (endTime - startTime) * staker.amountStaked * condition.rewardsPerUnitTime;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["248:            uint256 rewardsProduct = (endTime - startTime) * staker.amountStaked * condition.rewardsPerUnitTime;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["249:            uint256 rewardsPerTimeUnit = rewardsProduct / condition.timeUnit;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["266:            endTimestamp: block.timestamp + _endTime\n267:        });\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["270:            stakingConditions[conditionId - 1].endTimestamp = block.timestamp;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["302:            _rewards = stakers[_user].unclaimedRewards + _calculateRewards(_user);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["307:        uint256 rewards = stakers[msg.sender].unclaimedRewards + _calculateRewards(msg.sender);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["313:        stakers[msg.sender].conditionIdOflastUpdate = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["340:            uint256 amountToSend = rewardToken.balanceOf(address(this)) - rewardTokenBalance;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["379:        StakingCondition memory latestCondition = stakingConditions[nextConditionId - 1];\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["385:        uint256 rate = (totalStakedAmount * latestCondition.rewardsPerUnitTime) / latestCondition.timeUnit;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["385:        uint256 rate = (totalStakedAmount * latestCondition.rewardsPerUnitTime) / latestCondition.timeUnit;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["391:        uint256 currentConditionId = nextConditionId - 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["402:        uint256 remainingDuration = currentCondition.endTimestamp - block.timestamp;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["82:        if (raffle.ticketsSold + tickets > raffle.maxTickets) revert Gaia_MaxTicketExceeded();\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["83:        if (msg.value != raffle.ticketPrice * tickets) revert Gaia_NotEnoughFund();\n"],"loc":["./src/Raffle/Raffle.sol"]}]},{"severity":"Gas","title":"Use assembly to write storage values","description":"\n You can save a fair amount of gas by using assembly to write storage values. - Savings: ~66 \n","gasSavings":null,"category":null,"instances":[{"content":["28:        fee = _fee;\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["36:        fee = _newFee;\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["120:        collectionName = _collectionName;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["121:        description = _description;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["123:        rewardTokenAddress = _rewardTokenAddress;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["124:        stakingFee = _stakingFee;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["143:            isStaking = 2;\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["145:            isStaking = 1;\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Event is not properly indexed.","description":"\n When possible, always include a minimum of 3 indexed event topics to save gas - Savings: ~0 \n","gasSavings":null,"category":null,"instances":[{"content":["21:    event RaffleCreated(uint256 raffleId, address indexed creator, IERC721 indexed nft, uint256 tokenId);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["22:    event RaffleCancelled(uint256 raffleId);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["23:    event TicketPurchased(uint256 raffleId, address indexed participant, uint256 tickets);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["66:    event UpdatedRewardsPerUnitTime(uint256 oldRewardsPerUnitTime, uint256 newRewardsPerUnitTime);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["67:    event NFTStaked(uint256);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["69:    event UpdatedTimeUnit(uint256 oldTimeUnit, uint256 newTimeUnit);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["71:    event UpdatedEndTimestamp(uint256 oldEndTimestamp, uint256 newEndTimeStamp);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["74:    event RewardTokensDeposited(uint256 amountDeposited);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["77:    event ERC20Recovered(address indexed tokenAddress, address indexed recipient, uint256 amount);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["80:    event TokensWithdrawn(address indexed staker, uint256[] indexed tokenIds);\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["83:    event RewardsClaimed(address indexed staker, uint256 rewardAmount);\n"],"loc":["./src/Staking/GaiaStaking.sol"]}]},{"severity":"Gas","title":"Mark functions as payable (with discretion)","description":"\n You can mark public or external functions as payable to save gas. Functions that are not payable have additional logic to check if there was a value sent with a call, however, making a function payable eliminates this check. This optimization should be carefully considered due to potentially unwanted behavior when a function does not need to accept ether. - Savings: ~24 \n","gasSavings":null,"category":null,"instances":[{"content":["37:    function createRaffle(IERC721 _nft, uint256 _tokenId, uint256 _ticketPrice, uint256 _maxTickets) external {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["58:    function cancelRaffle(uint256 raffleId) external onlyRaffleCreator(raffleId) {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["97:    function withdrawEther() external onlyOwner {\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["35:    function updateFee(uint256 _newFee) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["80:    function withdrawEther() public onlyOwner returns (uint256 amount) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["91:    function getDeployedStakingContracts() external view returns (address[] memory) {\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]},{"content":["129:    function stakeTokens(uint256[] calldata _tokenIds) external whenNotPaused {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["159:    function unStake(uint256[] calldata _tokenIds) external {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["188:    function setRewardsPerUnitTime(uint256 _rewardsPerUnitTime) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["197:    function setTimeUnit(uint256 _timeUnit) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["206:    function setEndTimeStamp(uint256 _endTimestamp) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["216:    function depositRewardTokens(uint256 _amount) external onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["274:    function getStakeInfo(address _staker) external view returns (uint256[] memory _tokensStaked, uint256 _rewards) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["306:    function claimReward() external {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["320:    function onERC721Received(\n321:        address operator,\n322:        address from,\n323:        uint256 tokenId,\n324:        bytes calldata data\n325:    )\n326:        external\n327:        override\n328:        whenNotPaused\n329:        returns (bytes4)\n330:    {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["336:    function recoverERC20(address _tokenAddress, uint256 _amount) public onlyOwner {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["357:    function getStakersCount() external view returns (uint256) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["361:    function totalStaked() external view returns (uint256) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["371:    function poolRate() external view returns (uint256) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["390:    function rewardDuration() external view returns (uint256) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["4:    function id(uint256 value) external pure returns (uint256) {\n"],"loc":["./src/Foo.sol"]}]},{"severity":"Gas","title":"Use assembly when getting a contract's balance of ETH","description":"\n You can use `selfbalance()` instead of `address(this).balance` when getting your contract's balance of ETH to save gas. Additionally, you can use `balance(address)` instead of `address.balance()` when getting an external contract's balance of ETH. - Savings: ~15 \n","gasSavings":null,"category":null,"instances":[{"content":["98:        payable(owner()).transfer(address(this).balance);\n"],"loc":["./src/Raffle/Raffle.sol"]},{"content":["81:        amount = address(this).balance;\n"],"loc":["./src/Staking/GaiaStakingFactory.sol"]}]},{"severity":"Gas","title":"Cache array length during for loop definition.","description":"\n A typical for loop definition may look like: `for (uint256 i; i < arr.length; i++){}`. Instead of using `array.length`, cache the array length before the loop, and use the cached value to safe gas. This will avoid an `MLOAD` every loop for arrays stored in memory and an `SLOAD` for arrays stored in storage. This can have significant gas savings for arrays with a large length, especially if the array is stored in storage. - Savings: ~22 \n","gasSavings":null,"category":null,"instances":[{"content":["169:            for (uint256 i = 0; i < _stakersArray.length; ++i) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["364:        for (uint256 i = 0; i < stakersArray.length; i++) {\n"],"loc":["./src/Staking/GaiaStaking.sol"]},{"content":["64:        for (uint256 i = 0; i < raffle.participants.length; i++) {\n"],"loc":["./src/Raffle/Raffle.sol"]}]}]}